initialize() {
	// Parameters
	if (!exists("K_ANCESTRAL")) defineConstant("K_ANCESTRAL", 5000);
	if (!exists("nFounders")) defineConstant("nFounders", 1); // For later use
	
	// Constants
	defineConstant("L", 23e6); // Chromosome 2L
	defineConstant("REC_RATE", 2e-8);
	defineConstant("INV_START", 2.25e6);
	defineConstant("INV_END", 13.05e6);
	defineConstant("MU_DELETERIOUS", 1e-8);
	defineConstant("DFE_SHAPE", 0.2);
	defineConstant("DFE_MEAN_S", -0.01);
	defineConstant("H_DOMINANCE", 0.0); // Fully recessive for AOD
	
	// Timeline
	defineConstant("BURN_IN_GENS", 10 * K_ANCESTRAL); // 50,000 generations
	
	// Model setup
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=T);
	
	// Mutation types - only deleterious
	initializeMutationType("m2", H_DOMINANCE, "g", DFE_MEAN_S, DFE_SHAPE);
	m2.convertToSubstitution = F;
	
	// Genomic element - 100% deleterious mutations
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	
	initializeMutationRate(MU_DELETERIOUS);
	initializeRecombinationRate(REC_RATE);
}

// Create initial population
1 early() {
	sim.addSubpop("p1", K_ANCESTRAL);
	defineConstant("simID", getSeed());
}

// Random mating
reproduction() {
	mate1 = p1.sampleIndividuals(1);
	mate2 = p1.sampleIndividuals(1);
	p1.addCrossed(mate1, mate2);
}

// Burn-in: Accumulate deleterious load
1:BURN_IN_GENS early() {
	p1.fitnessScaling = K_ANCESTRAL / p1.individualCount;
}

// Track burn-in progress
1:BURN_IN_GENS late() {
	if (sim.cycle % 1000 == 0) {
		// Overall statistics
		meanFitness = mean(p1.cachedFitness(NULL));
		totalDel = sum(p1.individuals.haplosomes.countOfMutationsOfType(m2));
		meanDel = totalDel / (2.0 * p1.individualCount);
		
		// In inversion region specifically
		delInRegion = 0;
		for (h in p1.individuals.haplosomes) {
			muts = h.mutationsOfType(m2);
			inRegion = (muts.position >= INV_START) & (muts.position <= INV_END);
			delInRegion = delInRegion + sum(inRegion);
		}
		meanDelInRegion = delInRegion / (2.0 * p1.individualCount);
		
		catn("Gen " + sim.cycle + " | N: " + p1.individualCount +
		     " | Mean fitness: " + asFloat(meanFitness) +
		     " | Mean del. muts (genome): " + asFloat(meanDel) +
		     " | Mean del. muts (inv region): " + asFloat(meanDelInRegion));
		
		// Write to file
		line = paste(c(sim.cycle, p1.individualCount, meanFitness, meanDel, meanDelInRegion), sep="\t");
		filename = "burnin_K=" + K_ANCESTRAL + "_simID=" + simID + ".txt";
		
		if (sim.cycle == 1000) {
			header = "generation\tN\tmeanFitness\tmeanDelMuts\tmeanDelMutsInvRegion";
			writeFile(filename, header);
		}
		writeFile(filename, line, append=T);
	}
}

// Save burn-in state
BURN_IN_GENS late() {
	catn("\n=== Burn-in complete at generation " + sim.cycle + " ===");
	
	finalFitness = mean(p1.cachedFitness(NULL));
	finalDel = sum(p1.individuals.haplosomes.countOfMutationsOfType(m2)) / (2.0 * p1.individualCount);
	
	catn("Final mean fitness: " + finalFitness);
	catn("Final mean deleterious mutations per genome: " + finalDel);
	catn("Final population size: " + p1.individualCount);
	catn("\nSaving population state...");
	
	sim.outputFull("burnin_state_K=" + K_ANCESTRAL + "_simID=" + simID + ".txt");
	
	catn("Burn-in complete! Ready for inversion introduction.");
	sim.simulationFinished();
}
