// NULL vs True Overdominance power model 

initialize() {

    defineConstant("N_FOUNDERS_LOW", 4);

    // Genome
    defineConstant("L", 23e6);
    defineConstant("REC_RATE", 2e-8);
    defineConstant("INV_START", 2e6);
    defineConstant("INV_END", 13e6);
    defineConstant("INV_MARKER_POS",
                   integerDiv(INV_START + INV_END, 2));

    initializeSLiMModelType("nonWF");

    // Inversion marker
    initializeMutationType("m3", 0.5, "f", 0.0);
    m3.convertToSubstitution = F;

    initializeGenomicElementType("g1", m3, 1.0);
    initializeGenomicElement(g1, 0, L - 1);

    initializeMutationRate(0.0);
    initializeRecombinationRate(REC_RATE);

    // Reproducible RNG
    setSeed(100000 + REP_ID);
}



// True overdominance only when MODEL_TYPE == "TO"
fitnessEffect() {
    if (MODEL_TYPE != "TO")
        return 1.0;

    m3_count = individual.countOfMutationsOfType(m3);
    if (m3_count == 1) return 1.15;   // heterozygote advantage
    return 1.0;
}



// Setup cages
1 early() {

    // Create heterozygous founders
    sim.addSubpop("p1", 100);
    for (ind in p1.individuals)
        ind.haplosomes[0].addNewMutation(m3, 0.0, INV_MARKER_POS);

    defineConstant("START_GEN", sim.cycle);

    sim.addSubpop("p2", 0);   // LF
    sim.addSubpop("p3", 0);   // MF

    p2.takeMigrants(sample(p1.individuals, N_FOUNDERS_LOW));
    p3.takeMigrants(sample(p1.individuals, N_FOUNDERS_HIGH));

    sim.killIndividuals(p1.individuals);
    p1.removeSubpopulation();
}



// Reproduction
reproduction(p2) {
    for (i in 1:K_CAGE)
        p2.addCrossed(p2.sampleIndividuals(1),
                      p2.sampleIndividuals(1));
    self.active = 0;
}

reproduction(p3) {
    for (i in 1:K_CAGE)
        p3.addCrossed(p3.sampleIndividuals(1),
                      p3.sampleIndividuals(1));
    self.active = 0;
}



// Death
s1 2 early() {
    p2.fitnessScaling = K_CAGE / p2.individualCount;
    p3.fitnessScaling = K_CAGE / p3.individualCount;
}



// Recombination suppression inside inversion
recombination() {
    if (haplosome1.containsMarkerMutation(m3, INV_MARKER_POS) ==
        haplosome2.containsMarkerMutation(m3, INV_MARKER_POS))
        return F;

    inInv = (breakpoints > INV_START) & (breakpoints < INV_END);
    if (!any(inInv)) return F;

    breakpoints = breakpoints[!inInv];
    return T;
}


// Output
late() {

    if (sim.cycle == START_GEN + NUM_GEN) {

        // LF sample
        inds_LF = p2.individuals;
        if (size(inds_LF) > N_SAMPLE)
            inds_LF = sample(inds_LF, N_SAMPLE);

        m3_LF   = inds_LF.countOfMutationsOfType(m3);
        nSTD_LF = sum(m3_LF == 0);
        nHET_LF = sum(m3_LF == 1);
        nINV_LF = sum(m3_LF == 2);

        // MF sample
        inds_MF = p3.individuals;
        if (size(inds_MF) > N_SAMPLE)
            inds_MF = sample(inds_MF, N_SAMPLE);

        m3_MF   = inds_MF.countOfMutationsOfType(m3);
        nSTD_MF = sum(m3_MF == 0);
        nHET_MF = sum(m3_MF == 1);
        nINV_MF = sum(m3_MF == 2);

        line = paste(MODEL_TYPE, K_CAGE, NUM_GEN, N_SAMPLE,
                     N_FOUNDERS_HIGH,
                     nSTD_LF, nHET_LF, nINV_LF,
                     nSTD_MF, nHET_MF, nINV_MF,
                     sep=",");

        catn("Writing output to: " + OUTFILE);
        writeFile(OUTFILE, line, append=T);

        sim.simulationFinished();
    }
}
