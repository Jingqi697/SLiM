// Run 1000 independent replicates to capture cases where inversion persists

initialize() {
defineConstant("K_ANCESTRAL", 5000); // Population carrying capacity 
defineConstant("L", 23e6); // Chromosome 2L
defineConstant("REC_RATE", 2e-8); // Recombination rate
defineConstant("INV_START", 2e6);
defineConstant("INV_END", 13e6); // Inversion In(2L)t -- 11 Mb
defineConstant("MU_DELETERIOUS", 1e-8); 
defineConstant("DFE_SHAPE", 0.2);
defineConstant("DFE_MEAN_S", -0.03); // Deleterious mutation fitness cost, gamma distribution with mean of -0.05
defineConstant("P_DEL", 0.05); // Proportion of mutations that are highly deleterious (5%)
defineConstant("H_DOMINANCE", 0.0); // Fully recessive 
defineConstant("BURN_IN_GENS", 10 * K_ANCESTRAL); // Burn-in lasts for 50000 generations
defineConstant("INV_BURN_IN_GENS", 10 * K_ANCESTRAL);
// Model setup
initializeSLiMModelType("nonWF");
// Neutral mutation m2 
initializeMutationType("m2", H_DOMINANCE, "f", 0.0); 
m2.convertToSubstitution = F;
// Inversion marker m3
initializeMutationType("m3", 0.5, "f", 0.0); 
m3.convertToSubstitution = F;
defineConstant("INV_MARKER_POS", integerDiv(INV_START + INV_END, 2));
initializeGenomicElementType("g1", m2, 1.0);
initializeGenomicElement(g1, 0, L-1); // Standard chromosome
initializeMutationRate(MU_DELETERIOUS);
initializeRecombinationRate(REC_RATE);
}

// Load burn-in state
1 early() {
sim.readFromPopulationFile("burnin_state_K=5000_simID=6320324737315626724.txt"); //  Load burn-in population
setSeed(getSeed() + jobID); // Job ID for array
defineConstant("repID", getSeed()); // Store the seed for output
defineConstant("START_GEN", sim.cycle);
catn("Phase 2: Replicate " + jobID);
catn("Loaded burn-in state at generation " + START_GEN);

// Population dynamics
p1.fitnessScaling = K_ANCESTRAL / p1.individualCount;
}
// Reproduction
reproduction() {
mate1 = p1.sampleIndividuals(1);
mate2 = p1.sampleIndividuals(1);
p1.addCrossed(mate1, mate2);
}

// Introduce inversion at START_GEN
1: late() {
if (!exists("START_GEN")) return;
if (sim.cycle == START_GEN) {
p1.sampleIndividuals(1).haplosomes[0].addNewDrawnMutation(m3, INV_MARKER_POS); // Introduce inversion on 1 chromosome
inv_freq = sum(p1.individuals.haplosomes.countOfMutationsOfType(m3)) / (2.0 * p1.individualCount); // Calculate inversion frequency
catn("Generation " + sim.cycle + ": Inversion introduced. Frequency: " + inv_freq);
}
}

// Recombination suppression in heterozygotes
recombination() {
if (haplosome1.containsMarkerMutation(m3, INV_MARKER_POS) ==
haplosome2.containsMarkerMutation(m3, INV_MARKER_POS)) {
return F;
}
else {
inInv = (breakpoints > INV_START) & (breakpoints < INV_END);
if (!any(inInv)) {
return F;
}
else {
breakpoints = breakpoints[!inInv];
return T;
}
}
}

// Population dynamics
50001:100000 early() {
if (sim.cycle > START_GEN + INV_TRACKING_GENS) {
sim.simulationFinished();
}
p1.fitnessScaling = K_ANCESTRAL / p1.individualCount;
}

// Tracking
50001:100000 late() {
inv_count = sum(p1.individuals.haplosomes.countOfMutationsOfType(m3));
inv_freq = inv_count / (2.0 * p1.individualCount);

// Check for loss/fixation
if (inv_freq == 0.0) {
catn("Generation " + (sim.cycle - START_GEN) + ": Inversion LOST (replicate " + jobID + ")");
sim.simulationFinished();
}
if (inv_freq >= 0.99) {
catn("Generation " + (sim.cycle - START_GEN) + ": Inversion FIXED (replicate " + jobID + ")");
sim.simulationFinished();
}

// Log every 1000 generations after gen 1000
if (sim.cycle >= START_GEN + 1000 & (sim.cycle - START_GEN) % LOG_INTERVAL == 0) { // Logs only at intervals
numSTD = 0;
numHET = 0;
numINV = 0; // Number reset
for (ind in p1.individuals) {
inv_copies = sum(ind.haplosomes.countOfMutationsOfType(m3));
if (inv_copies == 0) numSTD = numSTD + 1;
else if (inv_copies == 1) numHET = numHET + 1;
else numINV = numINV + 1;
}
gensSinceIntro = sim.cycle - START_GEN;
catn("Gen " + gensSinceIntro + " (cycle " + sim.cycle + ") | Job " + jobID +
" | Inv freq: " + inv_freq +
" | STD: " + numSTD + " HET: " + numHET + " INV: " + numINV);
}

// Save if polymorphic
if (sim.cycle == START_GEN + INV_TRACKING_GENS) {
if (inv_freq > 0.0 & inv_freq < 0.99) {
catn("SUCCESS: Replicate " + jobID + " maintained polymorphism");
catn("Final inversion frequency: " + inv_freq);
outfile = "inversion_polymorphic_job=" + jobID + "_rep=" + repID + "_freq=" + inv_freq + ".txt";
sim.outputFull(outfile);
catn("Saved: " + outfile);
}
else {
catn("Replicate " + jobID + " did not maintain polymorphism (freq=" + inv_freq + ")");
}
sim.simulationFinished();
}
}
